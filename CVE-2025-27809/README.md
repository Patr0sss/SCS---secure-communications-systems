# TLS Hostname Validation Failure (CVE-2025-27809), Educational PoC


## Project Goal

Demonstrate how skipping **hostname (and certificate) validation** in a TLS client enables Man-in-the-Middle attacks, compromising otherwise "secure" communication.

***

## Important Note

In our proof-of-concept, we use the `-k` flag in `curl` as a practical simplification. This disables both Certificate Authority (CA) trust and hostname validation globally, which goes further than the specific logic flaw in *CVE-2025-27809*.

In real-world exploits (for example, in Mbed TLS before 2.28.10 and 3.x before 3.6.3.2), the vulnerability occurs if a client fails to call `mbedtls_ssl_set_hostname()`. This results in a TLS connection where hostname validation is silently skipped. A vulnerable client will then accept any certificate issued by a trusted CA, even if the certificate is for the wrong domain (for example, accepting a certificate for `google.com` when connecting to `bank.com`).

In our lab environment, we use self-signed certificates for simplicity. Generating and installing “trusted” CA certificates is not necessary for the demonstration. By using the `-k` flag, we effectively reproduce the practical outcome of the vulnerability: the client establishes a TLS session with the wrong server, making Man-in-the-Middle interception possible.

This approach makes the impact of improper TLS validation easy to observe and understand for educational purposes.

***

## Lab Architecture

| Component | Description |
| :-- | :-- |
| **Client** | `curlimages/curl` container acting as a vulnerable TLS client (`curl -k`). |
| **Attacker** | `mitmdump` (from `mitmproxy/mitmproxy`) — intercepting proxy (reverse HTTPS, with insecure SSL backend). |
| **Server** | `nginx:alpine` serving HTTPS using a self-signed certificate. |

All containers communicate **within a single Docker network**. No outside exposure.

Flow:

```
Client  →  Attacker (mitmdump)  →  Server
```


***

## Requirements

- Docker Engine
- Docker Compose

***

## Setup Guide

### 1. Clone this repository

```bash
git clone https://github.com/Patr0sss/SCS---secure-communications-systems.git
cd CVE-2025-27809
```


***

### 2. Generate TLS certificate for the server

```bash
mkdir certs
openssl req -x509 -newkey rsa:2048 -nodes -keyout certs/server.key -out certs/server.crt -days 3 -subj "/C=PL/ST=Test/L=Test/O=Lab/CN=server"
```


***

### 3. Start the lab with Docker Compose

```bash
docker compose up -d
```

This will launch all three containers (`client`, `mitmproxy`, `server`) in background.

***

### 4. Confirm all services are running

```bash
docker compose ps
```

You should see three containers (`client`, `mitmproxy`, `server`) with status "Up".

***

### 5. Simulate vulnerable TLS connection

Enter the client container’s shell:

```bash
docker compose exec client sh
```

Then, in the client:

```sh
curl -k https://mitmproxy:8080/
```

- `-k` disables all TLS verification!
- If DNS fails, find mitmproxy's IP with:

```bash
docker inspect -f "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}" mitm-mitmproxy-1
```

and use it:

```sh
curl -k https://<MITMPROXY_IP>:8080/
```


***

### 6. Observe intercepted traffic in mitmproxy logs

On the host:

```bash
docker compose logs mitmproxy
```

Typical output:

```
reverse proxy to https://server:443 listening at *:8080
GET https://server/
<< 200 OK
```

Mitmproxy shows full decrypted request/response traffic.

***

## How it works (Methodology)

- The client **does not check certificates or hostnames** (by design, `-k` flag).
- Mitmdump acts as a malicious (MITM) proxy.
- Communication is transparently decrypted and viewable in mitmdump logs.

***

## Results \& What to Observe

- Client believes the connection is “secure.”
- All TLS data can be read, logged and modified by mitmdump (Man-in-the-Middle).
- This *directly* demonstrates the risk described in CVE-2025-27809.

***

## Clean Up

To stop and remove everything:

```bash
docker compose down
```


***

